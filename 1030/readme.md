***

# 어셈블리 프로그래밍: 스택 조작과 프로시저 


***

## 1. 스택(Stack)의 구조와 작동 원리

- 스택은 **LIFO(Last-In First-Out)** 구조로 운영되며, 최상위 원소는 항상 ESP(Extended Stack Pointer) 레지스터가 가리킨다.
- **ESP (스택 포인터)**는 스택 영역의 현재 최상단 주소를 저장하며, 모든 PUSH와 POP 등 조작은 ESP에 영향을 준다.

***

## 2. 명령어: PUSH와 POP

### PUSH
- 설명: 지정된 값을 스택에 저장하는 명령어
- 동작 원리:  
  1. ESP 레지스터 값을 4만큼 감소시킨다 (즉, ESP = ESP - 4).  
  2. 감소된 ESP 지점에 소스 오퍼랜드 값을 복사한다.
- 용도: 임시 데이터 저장, 레지스터 보호, 함수 호출 시 인수 전달, 지역 변수 저장

```assembly
; 예제
push eax     ; EAX 값을 스택에 저장 (ESP - 4, 그 위치에 EAX값 저장)
push 1234h  ; 상수값을 스택에 저장
```

### POP
- 설명: 스택 최상단 값을 꺼내서 대상 레지스터 또는 메모리 위치에 저장하는 명령어
- 동작 원리:
  1. ESP가 가리키는 위치의 값을 대상에 복사
  2. ESP 값을 4만큼 증가시켜 스택 최상위 위치로 이동
- 용도: 저장했던 데이터 복원, 하위 레지스터 복구, 함수 반환 값 저장 등

```assembly
; 예제
pop eax      ; 스택의 가장 위 값이 EAX로 복사되고, ESP는 4만큼 증가
pop var     ; 변수 위치에 저장
```

***

## 3. 명령어의 상세 활용 사례와 주의점

### 레지스터 보존
- 함수 호출 전후 레지스터 값을 안전하게 유지하기 위해 PUSH/POP 사용
- 예를 들어, 함수 시작 시 `push eax`를 하고 끝나기 전에 `pop eax`를 해 레지스터값을 보호하는 패턴이 흔함

### `PUSHAD`와 `POPAD`
- `PUSHAD`: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI 를 모두 스택에 저장
- `POPAD`: 보존했던 8 개 레지스터를 복원

### 주의 사항
- ESP(스택 포인터)는 명령어 실행 후 항상 올바른 위치를 가리켜야 하며, 임의로 조작 시 스택이 손상될 수 있음.
- 함수의 인수는 `PUSH`로 넘기거나, 레지스터를 통해 전달해야 하며, 호출 후 반드시 `POP`으로 복구하는 습관이 중요.

***

## 4. 프로시저(Procedure)의 설계와 사용

- **정의**: `PROC` 명령으로 시작, `ENDP` 명령으로 종료
- **호출**: `CALL` 명령으로 호출 후, `RET` 명령으로 종료
- **인수 전달**: 대부분 레지스터 또는 스택 사용
- **레지스터 보존**: `USES` 키워드 또는 명시적 PUSH/POP 사용
- 예를 들어, 배열 원소의 합 계산, 정수 연산 등 다양한 기능 프로시저 설계 가능

### 예제: 배열 원소 합계
```assembly
ArraySum PROC
    push esi
    push ecx
    xor eax, eax
L1:
    add eax, [esi]
    add esi, 4
    loop L1
    pop ecx
    pop esi
    ret
ArraySum ENDP
```

## 5. Irvine32 라이브러리 활용
- 초보자용 함수 제공: 윈도우 콘솔 입출력, 난수, 문자열 처리 등
- 대표 함수:
  - `Clrscr`: 화면 청소
  - `WriteInt`, `WriteString`: 콘솔에 값 또는 문자열 출력
  - `ReadInt`, `ReadString`: 사용자 입력 받기
  - `Random32`: 난수 생성

### 활용 예시
```assembly
call Clrscr
mov eax, 123
call WriteInt
call Crlf
```

***

## 5. 결론

- `PUSH`와 `POP`은 함수 호출과 반환, 임시 데이터 저장을 위한 기본 명령어로, 반드시 사용법과 원리 숙지가 필요하다.
- 레지스터와 스택의 적절한 활용으로 안정적이고 효율적인 어셈블리 프로그래밍 가능.
- Irvine32 등 라이브러리 활용은 프로그래밍 생산성과 효율성을 높여준다.



***
