# 기말 시험

### 1. Write a sequence of statements that use only PUSH and POP instructions to exchange the values in the EAX and EBX registers (or RAX and RBX in 64-bit mode).

답
A : PUSH한 순서대로 POP하면 위치를 바꿀 수 있다.

```nasm
push eax
push ebx
pop eax
pop ebx
```

### 2. Create a procedure that generates a random string of length L, containing all capital letters. When calling the procedure, pass the value of L in EAX, and pass a pointer to an array of byte that will hold the random string. Write a test program that calls your procedure 20 times and displays the strings in the console window.

답

**A :** 길이 L의 랜덤 대문자 알파벳 문자열을 출력하는 프로시저를 작성하고 이를 20번 반복하기

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

.data
   strAlphabet DWORD 30			    ; 생성할 문자열의 길이
   buffer BYTE 100 DUP(?)           ; 충분한 길이의 버퍼 

.code
main PROC
    call Randomize                  ; 난수 초기화
    mov ecx, 20  		            ; 20개의 무작위 문자열 생성
GenLoop:
    call RandomString
    mov edx, OFFSET buffer
    call WriteString
    call Crlf
    loop GenLoop
    
    exit
main ENDP
;------------------------------------------------------------
; RandomString : 설정한 길이만큼 무작위 대문자 문자열 생성
; 입력 : ECX = 생성할 문자열의 길이
; 출력 : 버퍼에 무작위 대문자 문자열 저장
;------------------------------------------------------------
RandomString PROC USES ECX
    mov ecx, strAlphabet       ; 생성할 문자열의 길이 설정
    mov edi, OFFSET buffer     ; 버퍼의 시작 주소 설정

RandLoop:
    mov eax, 26                ; 알파벳 개수
    call RandomRange           ; EAX = 0 ~ 25
    add eax, 'A'               ; (0~25) -> ('A'~'Z')
    mov [edi], al              ; 버퍼에 문자 저장
    inc edi
    loop RandLoop

    mov byte ptr [edi], 0      ; 문자열 종료 문자 추가
    ret
RandomString ENDP

END main
```

### 3. Create a procedure that fills an array of doublewords with N random integers, making sure the values fall within the range j...k, inclusive. When calling the procedure, pass a pointer to the array that will hold the data, pass N, and pass the values of j and k. Preserve all register values between calls to the procedure. Write a test program that calls the procedure twice, using different values for j and k.

답

**A :** j~k 범위의 수들로 배열 채우기

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

.data
   array1 DWORD 10 DUP(?)  ;첫번째 실행
   array2 DWORD 10 DUP(?)  ;두번째 실행

.code
main PROC
    call Randomize  ;난수 초기화
    ;첫번째 배열 채우기
    push 9                  ;k 
    push 0                  ;j 
    push 10                 ;N 
    push OFFSET array1      
    call FillArray          

    push 100                ;k
    push 50                 ;j
    push 10                 ;N
    push OFFSET array2
    call FillArray

    push 10
    push OFFSET array1
    call PrintArray

    push 10
    push OFFSET array2
    call PrintArray

    exit
main ENDP
;------------------------------------------
; FillArray PROC
; 배열을 난수로 채우는 프로시저
; 매개변수:
; [ebp+8]  - 배열의 시작 주소
; [ebp+12] - 배열의 크기 N
; [ebp+16] - 난수의 최솟값 j
; [ebp+20] - 난수의 최댓값 k
;------------------------------------------
FillArray PROC
    push ebp
    mov ebp, esp
    pushad

    mov edi, [ebp+8]
    mov ecx, [ebp+12]
    mov ebx, [ebp+16]
    mov edx, [ebp+20]
fill:
    mov eax, edx
    sub eax, ebx             
    inc eax          ; k- j + 1
    call RandomRange ; 0~(k - j)
    add eax, ebx     ; j ~ k

    mov [edi], eax   ; 배열에 값 저장
    add edi, 4       ; 다음 요소로 이동
    loop fill

    popad
    pop ebp
    ret 16           ; 매개변수 4개(4*4=16) 정리
FillArray ENDP
;------------------------------------------
; PrintArray PROC
; 배열을 출력하는 프로시저
; 매개변수:
; [ebp+8]  - 배열의 시작 주소
; [ebp+12] - 배열의 크기 N
;------------------------------------------
PrintArray PROC
    push ebp
    mov ebp, esp
    pushad
    mov edi, [ebp+8]        ;배열의 시작 주소
    mov ecx, [ebp+12]       ;배열의 크기 N
print_loop:
    mov eax, [edi]
    call WriteDec
    mov al, ' '
    call WriteChar

    add edi, 4             ; 다음 요소로 이동
    loop print_loop

    call Crlf

    popad
    pop ebp
    ret 8                   ; 매개변수 2개(4*2=8) 정리
PrintArray ENDP

END main
```

### 4. Write a program that generates all prime numbers between 2 and 1000, using the Sieve of Eratosthenes method. You can find many articles that describe the method for finding primes in this manner on the Internet. Display all the prime values.

답

A : 2~1000 사이의 소수를 에라토스테네스의 방법으로 모두 생성하는 프로그램 작성

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

.data
    val BYTE 1001 DUP(1)    ; 0~1000 까지 초기값은 모두 1
    space BYTE ' ', 0

.code
main PROC
    ; 0과 1은 소수가 아님
    mov BYTE PTR val[0], 0
    mov BYTE PTR val[1], 0

    call FindPrime          ; 소수를 구하고
    call PrintPrimes        ; 출력

    exit 
main ENDP
;-------------------------------------------------
; FindPrime
; 에라토스테네스의 체 알고리즘 구현
; 2부터 sqrt(1000)(≒32)까지 반복
; 소수가 아니라면 0으로 표시
; 입력 없음
; 출력 : val 배열에 소수 표시
;-------------------------------------------------
FindPrime PROC
    mov ebx, 2          ; 2의 배수부터 찾아라
NextPRime:
    cmp ebx, 32         ; sqrt(1000) 정도인 32까지 반복
    jge done

    mov al, val[ebx]
    cmp al, 1           ; 지금 숫자가 1이 아니면
    jne EndMulti        ; 소수가 아님-> 배수 제거 루틴 건너뜀

    ; ebx의 배수를 0으로 표시하는 루프
    mov edi, ebx
Multi:
    add edi, ebx        ; 다음 배수
    cmp edi, 1001       ; 배열 범위를 넘어가면 종료
    jge EndMulti
    mov BYTE PTR val[edi], 0
    jmp Multi
EndMulti:
    inc ebx             ; 다음 수도 조사한다
    jmp NextPrime
done:
    ret
FindPrime ENDP
;-------------------------------------------------
; PrintPrimes
; val 배열에서 1로 표시된 소수를 출력하는 프로시저
;-------------------------------------------------
PrintPrimes PROC
    mov esi, OFFSET val
    mov ecx, 1001
    xor edi, edi
PrintLoop:
    mov al, [esi]
    cmp al, 1
    jne NotPrime        ; 1이 아니면 소수가 아님

    mov eax, esi
    sub eax, OFFSET val ; 1인 소수들의 정보가 담긴 주소값 - 배열 시작 주소 = 소수
    call WriteDec
    mov edx, OFFSET space
    call WriteString    ; 소수들은 공백으로 구분

    inc edi
    cmp edi, 10 
    jne NotTen
    call Crlf           ; 소수를 10개 출력 했다면 줄 바꿈
    xor edi, edi
NotTen:
NotPrime:
    inc esi
    loop PrintLoop
    ret
   PrintPrimes ENDP

END main
```

### 5. The greatest common divisor (GCD) of two integers is the largest integer that will evenly divide both integers. The GCD algorithm involves integer division in a loop, described by the following pseudocode:

```nasm
int GCD(int x, int y)
{
x = abs(x) // absolute value
y = abs(y)
do {
int n = x % y
x = y
y = n
} while (y > 0)
return x
}
```

### Implement this function in assembly language and write a test program that calls the function several times, passing it different values. Display all results on the screen.

답

**A :** 위의 의사코드에 따라 두 정수의 최대공약수를 구하는 알고리즘 구현

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

.data
    val DWORD 48, 18, 81, 153, 270, 96, 42, 6
    pair = LENGTHOF val / 2

    msgOpen BYTE "GCD(", 0
    msgComma BYTE ", ", 0
    msgClose BYTE ") = ", 0
.code
main PROC
    mov esi, OFFSET val     ; 현재 정수 쌍의 주소
    mov ecx, pair           ; 반복 횟수(정수쌍의 개수)
TestLoop:
    mov edx, OFFSET msgOpen
    call WriteString

    mov eax, [esi]          ; 첫 번째 정수
    call WriteInt

    mov edx, OFFSET msgComma
    call WriteString

    mov eax, [esi+4]        ; 두 번째 정수
    call WriteInt

    mov edx, OFFSET msgClose
    call WriteString

    mov eax, [esi]
    mov ebx, [esi + 4]
    call GCDP

    call WriteInt
    call Crlf
    add esi, 8              ; 다음 정수 쌍 주소
    loop TestLoop

    exit 
main ENDP
;------------------------------------------------------------
; GCDP
; 두 정수의 최대공약수를 구하는 프로시저
; 입력 : EAX = 첫 번째 정수 x
;        EBX = 두 번째 정수 y
; 출력 : 최대 공약수
;------------------------------------------------------------
GCDP PROC
    cmp eax, 0
    jge AbsXdone
    neg eax                 ; x가 음수라면 절댓값으로
AbsXdone:
    cmp ebx, 0
    jge AbsYdone
    neg ebx                 ; y가 음수라면 절댓값으로
AbsYdone:

    cmp ebx, 0
    jne GCDLoop
    ret                     ; y가 0이면 x가 이미 최대공약수이므로 반환
GCDLoop:
    mov edx, 0              ; 상위 32비트를 0으로 클리어
    div ebx                 ; (EDX : EAX) => 몫은 EAX, 나머지는 EDX
    mov eax, ebx            ; x = y
    mov ebx, edx            ; y = 이전 나머지 값으로 교체
    cmp ebx, 0
    jne GCDLoop             ; 나머지가 0이 될 때까지 반복

    ret                     ; y가 0이면 현재 x가 최대공약수
GCDP ENDP

END main
```

### 6. Write a procedure named CountMatches that receives points to two arrays of signed double words, and a third parameter that indicates the length of the two arrays. For each element xi in the first array, if the corresponding yi in the second array is equal, increment a count. At the end, return a count of the number of matching array elements in EAX. Write a test program that calls your procedure and passes pointers to two different pairs of arrays. Use the INVOKE statement to call your procedure and pass stack parameters. Create a PROTO declaration for CountMatches. Save and restore any registers (other than EAX) changed by your procedure.

답

**A :** 두 배열의 동일 인덱스의 값이 같은 개수를 구하는 프로시저

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

CountMatches PROTO array1Ptr:PTR SDWORD,
                    array2Ptr:PTR SDWORD,
                    lenArr:DWORD

.data
    arr1 SDWORD 10, -3, 25, 40, 8, 4, 9, -12
    arr2 SDWORD 10, -3, 20, 40, 7, 4, 10, -12
    len1 DWORD LENGTHOF arr1

    arr3 SDWORD 1,2,3,4,5,6,7,8,9
    arr4 SDWORD 1,0,3,0,5,0,0,0,9
    len2 DWORD LENGTHOF arr3
.code
main PROC
    INVOKE CountMatches, ADDR arr1, ADDR arr2, len1
    call WriteDec
    call Crlf
    INVOKE CountMatches, ADDR arr3, ADDR arr4, len2
    call WriteDec
    call Crlf
    exit 
main ENDP
;-----------------------------------------------------------
CountMatches PROC USES ebx ecx edx,
    array1Ptr:PTR SDWORD,
    array2Ptr:PTR SDWORD,
    lenArr:DWORD
; x[i]==y[i]인 경우의 개수를 세는 프로시저
; 받은 파라미터:
;   array1Ptr = 첫 번째 배열의 주소
;   array2Ptr = 두 번째 배열의 주소
;   length = 배열 크기
; 반환값 : EAX = 일치한 요소 개수
;-----------------------------------------------------------
    xor eax, eax            ; count = 0
    mov ecx, lenArr
    mov ebx, 0
match:
    cmp ecx, 0
    je finish

    mov edx, array1Ptr      ; arr[i]값 가져오기
    mov esi, [edx+ebx*4]

    mov edx, array2Ptr      ; arr[i]값 가져오기
    mov edi, [edx+ebx*4]

    cmp esi, edi
    jne noMatch
    inc eax                 ; 같으면 count++
noMatch:
    inc ebx                 ; 다음 인덱스로 이동
    loop match
finish:
    ret
CountMatches ENDP

END main
```

### 7. Rewrite the binary search procedure shown in this chapter by using registers for mid, first, and last. Add comments to clarify the registers’ usage.

답

**A :** 레지스터만을 이용하여 표현한 이진탐색 알고리즘

```nasm
.386
.MODEL FLAT, STDCALL
.STACK 4096
include Irvine32.inc

BinarySearch PROTO, pArray:PTR DWORD, count:DWORD, searchVal:DWORD
PrintArray PROTO, pArray:PTR DWORD, count:DWORD

.data
    array DWORD 1, 3, 5, 7, 9, 11, 13, 15
    arrayCount DWORD LENGTHOF array
    Val DWORD 11
    space BYTE ' ', 0
    mArray BYTE "배열 내용: ", 0
    mFind BYTE "검색 값 위치: ", 0
    mFail BYTE "값을 찾지 못함", 0
.code
main PROC
    mov edx, OFFSET mArray
    call WriteString
    INVOKE PrintArray, ADDR array, arrayCount
    call Crlf
    INVOKE BinarySearch, ADDR array, arrayCount, Val

    cmp eax, -1
    je NotFound

    mov edx, OFFSET mFind
    call WriteString
    call WriteInt
    call Crlf
    jmp done
NotFound:
    mov edx, OFFSET mFail
    call WriteString
    call Crlf
done:
    exit
main ENDP
;---------------------------------------------------------------
PrintArray PROC USES esi ecx eax,
    pArray:PTR DWORD,
    count:DWORD
; 받은 파라미터:
;   pArray = 배열의 시작 주소
;   count = 배열의 길이
; 배열을 출력하는 프로시저
;---------------------------------------------------------------
    mov esi, pArray
    mov ecx, count
L1:
    mov eax, [esi]
    call WriteInt
    mov edx, OFFSET space
    call WriteString

    add esi, 4
    loop L1
    ret 8
PrintArray ENDP
;---------------------------------------------------------------
BinarySearch PROC USES ebx ecx edx esi edi,
    pArray:PTR DWORD,
    count:DWORD,
    searchVal:DWORD
; 이진 탐색을 수행하는 프로시저 (레지스터만을 사용하여)
; 받은 파라미터:
;   pArray = 배열의 시작 주소
;   count = 배열의 길이
;   searchVal = 찾을 값
; 반환값 : EAX = 찾은 인덱스, 못 찾았다면 -1
;---------------------------------------------------------------
    mov ebx, pArray             ; EBX = 배열 시작 주소
    mov esi, 0                  ; ESI = first = 0
    mov eax, count
    dec eax
    mov edi, eax                ; EDI = last = count - 1
L1:
    cmp esi, edi                ; first <= last 일 동안 수행
    jg NotFound

    mov edx, esi                ; EDX = mid
    add edx, edi                ; mid = (first + last)
    shr edx, 1                  ;           / 2

    mov ecx, edx
    shl ecx, 2                  ; 인덱스 x4
    mov eax, [ebx+ecx]
    cmp eax, searchVal
    jl GoRight                  ; array[mid] < Val 이면 오른쪽,
    jg GoLeft                   ; array[mid] > Val 이면 왼쪽 탐색

    mov eax, edx                ; 동일하다면 찾은것, 인덱스를 전달
    ret 12
GoRight:
    mov esi, edx
    inc esi                     ; esi(first) = mid(edx) + 1
    jmp L1
GoLeft:
    mov edi, edx
    dec edi                     ; edi(last)  = mid(edx) - 1
    jmp L1
NotFound:
    mov eax, -1                 ; 발견 못했으면 -1 반환
    ret 12
BinarySearch ENDP
END main
```

### 8. Create a macro named mReadInt that reads a 16- or 32-bit signed integer from standard input and returns the value in an argument. Use conditional operators to allow the macro to adapt to the size of the desired result. Write a program that tests the macro, passing it operands of various sizes.

답

A: 매크로를 이용해 자료형 크기에 따라 동작이 달라지는 입력 기능을 구현할 수 있는지

```nasm
INCLUDE Irvine32.inc

mReadInt MACRO dest
    IF TYPE dest EQ WORD
        call ReadInt
        mov dest, ax
    ELSEIF TYPE dest EQ DWORD
        call ReadInt
        mov dest, eax
    ENDIF
ENDM

.data
    num16 WORD ?
    num32 DWORD ?

.code
main PROC
    mReadInt num16
    mReadInt num32
    exit
main ENDP
END main

```

### 9. 인의예지신과 중도에 대해 기술하시오.

인:측은지심

의:수오지심

예:사양지심

지:시비지심

신:광명지심

중도: 정도를 지키며 조화를 맞춤